<?php

/**
 *  Implementation of hook_block
 */
function twitter_block($op = 'list', $delta = 0, $edit = array()) {
  switch($op) {
    case 'list':
      $result = db_query("SELECT blockid, username FROM twitter_cache");
      while($row = db_fetch_array($result)) {
        $blocks[$row['blockid']]['info'] = "@" . $row['username'] . "'s Twitter feed";
      }
      $blocks['new']['info'] = "New Twitter Feed";
      $blocks['new']['region'] = "-1";
      return $blocks;
    case 'configure':
      $form = array();
      if($delta == 'new') {
        $form['twitter_username'] = array(
          '#type' => 'textfield',
          '#title' => t('The twitter username to follow'),
          '#default_value' => '',
          '#size' => 20,
          '#maxlength' => 255,
          '#description' => t('The username of a public twitter account you want to display.'),
        );
      } else {
        $result = db_query("SELECT * FROM twitter_cache WHERE blockid=%d", $delta);
        if($row = db_fetch_array($result)) {
          $form['twitter_username'] = array(
            '#type' => 'textfield',
            '#title' => t('The twitter username to follow'),
            '#default_value' => $row['username'],
            '#size' => 40,
            '#maxlength' => 255,
            '#description' => t('The username of a public twitter account you want to display.'),
          );
          $form['twitter_delete'] = array(
            '#type' => 'checkbox',
            '#title' => t('Delete this block'),
            '#default_value' => FALSE,
          );
        }
      }
      return $form;
    case 'save':
      if($delta == 'new') {
        $data = array(
          'username' => $edit['twitter_username'],
          'show_items' => 5,
          'show_at_tweets' => FALSE,
          'cache_time' => strftime("%Y-%m-%d %H:%M:%S", 0));
        drupal_write_record('twitter_cache',$data);
      } else {
        $result = db_query("SELECT * FROM twitter_cache WHERE blockid=%d", $delta);
        if($row = db_fetch_array($result)) {
          if($edit['twitter_delete'] == 1) {
            db_query("DELETE FROM twitter_cache WHERE blockid=%d", $delta);
          } else {
            $data = array(
              'username' => $edit['twitter_username'],
              'show_items' => 5,
              'show_at_tweets' => FALSE,
              'blockid' => $delta,
              'cache_time' => strftime("%Y-%m-%d %H:%M:%S", 0), //reset the cache time to the epoch to make sure this gets rebuilt
            );
            drupal_write_record('twitter_cache', $data, 'blockid');
          }
        }
      }
      return;      
    case 'view': default:
      // always include the css file
      $cssPath = drupal_get_path('module', 'twitter') . "/twitter.css";
      drupal_add_css($cssPath, 'module', 'all', FALSE);
      // see if there is a block with this delta in the database
      $result = db_query("SELECT * FROM twitter_cache WHERE blockid=%d", $delta);
      $block = array();
      if( $row = db_fetch_array($result)) {
        $block['subject'] = "@" . $row['username'] . "'s Tweets";
        $block['content'] = "";
        // now need to see what the timestamp on the cache is
        if(strtotime($row['cache_time']) < (time() - (15 * 60))) {
          // need to refresh cache
          $block['content'] .= "<p>Refreshing Cache</p>\n";
          $messages = user_timeline($row['username'], $row['show_items'], $row['show_at_tweets']);
          $data = array(
            'blockid' => $delta,
            'cache' => serialize($messages),
            'cache_time' => strftime("%Y-%m-%d %H:%M:%S"),
          );
          drupal_write_record('twitter_cache', $data, 'blockid');
        } else {
          // cache is new enough
          $block['content'] .= sprintf("<p>Loading from cache %d %d</p>\n", strtotime($row['cache_time']), time() - (60*15));
          $messages = unserialize($row['cache']);
        }
        foreach($messages as $msg) {
          $block['content'] .= "<div class='tweet'>\n  <p>" . $msg['text'] . "</p>\n";
          $block['content'] .= "  <p><span class='twitter-details'>On " . strftime("%e %b %Y", $msg['date']);
          $block['content'] .= " at " . strftime("%H:%M", $msg['date']) . " From " . $msg['source'] . "</span></p>\n</div>\n";
        }
      }
      return $block;    
  }
}

/**
 *  Implementation of hook_menu()
 */
function twitter_menu() {
  $items = array();
  $items['admin/settings/twitter'] = array(
  'title' => 'Twitter Settings',
  'description' => 'Set up twitter feed blocks',
  'page callback' => 'drupal_get_form',
  'page arguments' => array('twitter_admin_settings'),
  'access arguments' => array('administer twitter'),
  );
  return $items;
}

/**
 *  Admin settings
 */
function twitter_admin_settings() {
  $form['twitter_settings'] = array(
  '#type' => 'fieldset',
  '#title' => t('Twitter Settings'),
  '#collapsible' => False,
  '#collapsed' => False,
  );
  $form['twitter_settings']['twitter_username'] = array(
  '#type' => 'textfield',
  '#title' => t('Your twitter user name'),
  '#default_value' => variable_get('twitter_username', ''),
  '#size' => 20,
  '#maxlength' => 40,
  '#description' => t('The username of a public twitter account you want to display.'),
  );
  return system_settings_form($form);
}

/**
 *  implementation of hook_perm
 */
function twitter_perm() {
  return array('administer twitter');
}

function user_timeline($username, $n = 10, $keep_at_messages = False) {
  $pr = curl_init("http://twitter.com/statuses/user_timeline.xml?screen_name=" . $username);
  ob_start();
  curl_exec($pr);
  $res = ob_get_contents();
  ob_end_clean();
  curl_close($pr);
  /* now parse the xml a bit */
  $parser = new twitter_xml_parser();
  $xml_array = $parser->parse($res);

  $print_msg = array();
  $xml_array = array_reverse($xml_array);
  for($i=0;$i<$n;$i++) {
    if($keep_at_messages == False) {
      while(count($xml_array) > 0) {
        $msg = array_pop($xml_array);
        if(substr($msg['text'],0,1) != "@") {
          $print_msg[] = $msg;
          break;
        }
      }
    } else {
      $print_msg[] = array_pop($xml_array);
    }
  }
  return $print_msg;
}

class twitter_xml_parser {
  function twitter_xml_parser() {
    $this->parser = xml_parser_create();

    //xml_set_object($parser, $this);

    xml_set_element_handler($this->parser, array($this, 'tagStart'), array($this, 'tagEnd'));
    xml_set_character_data_handler($this->parser, array($this, 'tagContent'));

    $this->xml_data = array();
    $this->text_chunk = "";
    $this->mode = "idle";
    $this->inside = array();
    $this->xmlwl = new xmlWhitelist();
  }

  function tagStart($parser, $name, $attribs) {
    if($name == "STATUS") {
      $this->xml_data[count($this->xml_data)] = array();
    } elseif($name == "TEXT") {
      $this->mode = "grab_text";
      $this->text_chunk = "";
    } elseif($name == "SOURCE") {
      $this->mode = "grab_text";
      $this->text_chunk = "";
    } elseif($name == "CREATED_AT") {
      $this->mode = "grab_text";
      $this->text_chunk = "";
    }
    $this->inside[] = $name;
  }

  function tagEnd($parser, $name) {
    array_pop($this->inside);
    if($name == "TEXT") {
      $this->xml_data[count($this->xml_data) - 1]['text'] = $this->xmlwl->parse($this->text_chunk);
      $this->mode = "idle";
    } elseif($name == "SOURCE") {
      $this->xml_data[count($this->xml_data) - 1]['source'] = $this->xmlwl->parse($this->text_chunk);
      $this->mode = "idle";
    } elseif($name == "CREATED_AT" && $this->inside[count($this->inside)-1] == "STATUS") {
      $ptime = strptime($this->text_chunk, "%a %b %d %H:%M:%S %z %Y");
      $this->xml_data[count($this->xml_data) - 1]['date'] = mktime($ptime['tm_hour'], $ptime['tm_min'], $ptime['tm_sec'], $ptime['tm_mon'] + 1, $ptime['tm_mday'], $ptime['tm_year'] + 1900);
      $this->mode = "idle";
    }
  }

  function tagContent($parser, $data) {
    if($this->mode == "grab_text") {
      $this->text_chunk .= $data;
    }
  }

  function parse($xml) {
    xml_parse($this->parser, $xml);
    return $this->xml_data;
  }
}

class xmlWhitelist {
  function tagStart($name, $attribs) {
    if(array_key_exists($name, $this->allowed_tags)) {
      // allowed tag, need to check attributes
      $this->xml_data .= "<" . $name;
      foreach($attribs as $key=>$val) {
        if(array_key_exists($key, $this->allowed_tags[$name]['attribs'])) {
          // allowed attribute, check content against re
          if(preg_match($this->allowed_tags[$name]['attribs'][$key], $val) == 1) {
            $this->xml_data .= " " . $key . "='" . $val . "'";
          }
        }
      }
      if($this->allowed_tags[$name]['keep_content']) {
        $this->keep_stack[] = TRUE;
      } else {
        $this->keep_stack[] = FALSE;
      }
      $this->xml_data .= ">";
    }
  }

  function tagEnd($name) {
    if(array_key_exists($name, $this->allowed_tags)) {
      $this->xml_data .= "</" . $name . ">";
    }
    array_pop($this->keep_stack);
  }

  function tagContent($data) {
    if($this->keep_stack[count($this->keep_stack) - 1]) {
      $this->xml_data .= $data;
    }
  }

  function parse($data) {
    $this->xml_data = "";
    $this->allowed_tags = array();
    $this->allowed_tags['a'] = array(
      'attribs' => array(
        'href' => '/^http/',
        'rel' => '/^nofollow/',
      ),
      'keep_content' => TRUE);
    $this->keep_stack = array(TRUE);
    
    while(strlen($data) > 0) {
      $t = strpos($data,"<");
      if($t===FALSE) {
        $this->tagContent($data);
        break;
      }
      $this->tagContent(substr($data,0,$t));
      $data = substr($data,$t);

      // find the end of the tag
      $te = strpos($data,">");
      if($te === FALSE) {
        print "Invalid XML - Unclosed tag after " . $data;
        return FALSE;
      }

      $tag = substr($data, 0, $te + 1);
      // see if it's an open or close tag or both.
      $tt = 'open';
      $tc = substr($tag,1,-1);
      if(substr($tc,0,1) == "/") {
        $tt = 'close';
        $tc = substr($tag,2,-1);
      } elseif(substr($tc,-1) == "/") {
        // open and close call both
        $tt = 'both';
        $tc = substr($tag,1,-2);
      }
      if($tt == 'close') {
        $this->tagEnd(trim($tc));
      } else {
        // find the first space
        $bits = explode(" ", $tc);
        $tn = $bits[0];
        $bits = array_slice($bits,1);
        $attribs = array();
        foreach($bits as $attr) {
          list($key, $val) = explode("=", trim($attr), 2);
          $attribs[$key] = substr($val, 1, -1);
        }
        $this->tagStart($tn, $attribs);
        if($tt == "both") {
          $this->tagEnd($tn);
        }
      }
      $data = substr($data, $te + 1);
    }
    return $this->xml_data;
  }
}

?>
